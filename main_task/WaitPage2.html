{% extends "global/NoRefreshWaitPage.html" %}
{% load otree static %}

{% block title %}{% endblock %}

{% block content %}

    <style>
        .center-text {
            text-align: center;
        }
        p {
            font-size: 20px;
        }
        img {
            width: 60%;
            max-width: 800px;
            margin: 20px 0;
        }
        .timer-container {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 20px auto;
            max-width: 500px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .timer {
            font-size: 28px;
            font-weight: bold;
            color: #dc3545;
            margin-top: 10px;
        }
        .counter-container {
            background-color: #e6f7ff;
            border-radius: 8px;
            padding: 15px;
            margin: 20px auto;
            max-width: 500px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .counter {
            font-size: 24px;
            font-weight: bold;
            color: #0066cc;
        }
    </style>

    <div style="text-align: center;">
        <h2>Waiting for other players to join...</h2>
        <br>

        <!-- Participant Counter -->
        <div class="counter-container">
            <p>Currently waiting: <span class="counter" id="waiting-count">{{ waiting_participants }}</span> of {{ players_per_group }} players</p>
            {% if players_needed > 0 %}
                <p>Need <span class="counter" id="needed-count">{{ players_needed }}</span> more to start</p>
            {% endif %}
        </div>
        
        <!-- Countdown Timer -->
        <div class="timer-container">
            <p>Time remaining before automatic return to Prolific:</p>
            <div class="timer" id="countdown-timer">10:00</div>
        </div>
        <br>

        <p>Each game is made up of <b>5 participants,</b> please wait to be matched.</p>
        <p><b>Please stay on this screen</b> so that you are ready to start as soon as your group is complete.</p>
        <br>
        <p><b>If after 10 minutes you are still waiting to be matched, you will be automatically be re-directed to Prolific and the study will end.</b>
        <br><br>
            This is because we will assume that there are not enough players left in the study to form a group of 5, and we don't want you to be waiting around for too long. If this happens, you will still be paid appropriately for your time.</p>
        <br>
        <p>The page will refresh every 30 seconds to update the number of players waiting, however this <b>does not</b> reset the 10 minute timer.</p>
        <p>If you would like to return to Prolific at any point, please press the button below.</p>
        <p>You will be paid approximately Â£2 for your time, and it will not affect your submission rate.</p>
        <button id="return-button" style="font-size: 18px; padding: 10px 20px; background-color: red; color: white; border: none; cursor: pointer;">Return to Prolific</button>
        <br><br>
        <img src="{% static 'instructions/button_diagram_main.png' %}" alt="Buttons">
    </div>

    <div style="text-align: center; margin-top: 30px;">
        <h3>Bored waiting for the others to catch up? Try this Snake game!</h3>
        <p>Use WASD keys to control the snake. Eat the food to grow and score points.</p>
        <p>Unfortunately the page refreshes will reset your progress, sorry!</p>
        <br>
        <p>Press 'W', 'A', 'S', or 'D' to begin!</p>

        <canvas id="snakeCanvas" width="300" height="300" style="border:2px solid #333; border-radius: 5px; box-shadow: 0 0 10px rgba(0,0,0,0.1);"></canvas>
        <p>Your score: <span id="score" style="font-weight: bold; font-size: 24px; color: #4CAF50;">0</span></p>
    </div>

    <script>
        // Get the wait page exit link from js_vars
        var waitpagelink = js_vars.waitpagelink;

        // Set up the countdown timer - store in sessionStorage to prevent reset on page refresh
        let startTime;
        if (sessionStorage.getItem('waitPage2CountdownStart')) {
            startTime = parseInt(sessionStorage.getItem('waitPage2CountdownStart'));
        } else {
            startTime = Date.now();
            sessionStorage.setItem('waitPage2CountdownStart', startTime);
        }

        const countdownDisplay = document.getElementById('countdown-timer');
        const totalWaitTime = 600; // 10 minutes in seconds

        // Initialize the timer interval
        const timerInterval = setInterval(updateTimer, 1000);

        function updateTimer() {
            const currentTime = Date.now();
            const elapsedSeconds = Math.floor((currentTime - startTime) / 1000);
            const remainingSeconds = totalWaitTime - elapsedSeconds;
            
            if (remainingSeconds <= 0) {
                clearInterval(timerInterval);
                window.location.href = waitpagelink;
                return;
            }
            
            // Format time as MM:SS
            const minutes = Math.floor(remainingSeconds / 60);
            const seconds = remainingSeconds % 60;
            countdownDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Set up automatic page refresh but preserve timer
        function setupPageRefresh() {
            // Refresh the page every 30 seconds
            setTimeout(function() {
                // Store current time in session storage before refresh
                sessionStorage.setItem('waitPage2CountdownStart', startTime);
                
                // Reload the page
                window.location.reload();
            }, 30000); // 30 seconds
        }

        // Initialize page refresh timer
        setupPageRefresh();

        let returnButton = document.getElementById('return-button');

        returnButton.addEventListener('click', () => {
            clearInterval(timerInterval); // Clear the timer interval
            sessionStorage.removeItem('waitPage2StartTime'); // Clean up
            sessionStorage.removeItem('waitPage2CountdownStart'); // Clean up countdown timer
            window.location.href = waitpagelink;
        });

        // Snake Game
        const canvas = document.getElementById('snakeCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const gridSize = 15;
        const tileCount = 20;

        let snake, food, dx, dy, gameStarted, score, gameLoop, gameSpeed;

        function initGame() {
            snake = [{x: Math.floor(Math.random() * tileCount) * gridSize, y: Math.floor(Math.random() * tileCount) * gridSize}];
            food = {x: 0, y: 0};
            dx = 0;
            dy = 0;
            gameStarted = false;
            score = 0;
            gameSpeed = 100;
            scoreDisplay.textContent = score;
            generateFood();
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(step, gameSpeed);
        }

        function drawSnakePart(snakePart, index) {
            const hue = (120 + index * 3) % 360;  // Gradual color change
            ctx.fillStyle = `hsl(${hue}, 100%, 40%)`;
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.fillRect(snakePart.x, snakePart.y, gridSize, gridSize);
            ctx.strokeRect(snakePart.x, snakePart.y, gridSize, gridSize);
            
            // Add eye to the head
            if (index === 0) {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(snakePart.x + gridSize * 0.3, snakePart.y + gridSize * 0.3, gridSize * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(snakePart.x + gridSize * 0.3, snakePart.y + gridSize * 0.3, gridSize * 0.1, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawSnake() {
            snake.forEach(drawSnakePart);
        }

        function drawFood() {
            ctx.fillStyle = '#FF6347';  // Tomato red
            ctx.beginPath();
            ctx.arc(food.x + gridSize/2, food.y + gridSize/2, gridSize/2, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#8B0000';  // Dark red
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function moveSnake() {
            if (!gameStarted) return;
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreDisplay.textContent = score;
                generateFood();
                increaseSpeed();
            } else {
                snake.pop();
            }
        }

        function generateFood() {
            food.x = Math.floor(Math.random() * tileCount) * gridSize;
            food.y = Math.floor(Math.random() * tileCount) * gridSize;
        }

        function clearCanvas() {
            ctx.fillStyle = '#F0F8FF';  // Light blue background
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function checkCollision() {
            const head = snake[0];
            if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
                return true;
            }
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }

        function step() {
            if (checkCollision()) {
                initGame();
                return;
            }
            clearCanvas();
            drawFood();
            moveSnake();
            drawSnake();
        }

        function increaseSpeed() {
            gameSpeed *= 0.98;
            clearInterval(gameLoop);
            gameLoop = setInterval(step, gameSpeed);
        }

        document.addEventListener('keydown', changeDirection);

        function changeDirection(event) {
            const key = event.key.toLowerCase();
            const goingUp = dy === -gridSize;
            const goingDown = dy === gridSize;
            const goingRight = dx === gridSize;
            const goingLeft = dx === -gridSize;

            if (key === 'a' && !goingRight) {
                dx = -gridSize;
                dy = 0;
                if (!gameStarted) gameStarted = true;
            }
            if (key === 'w' && !goingDown) {
                dx = 0;
                dy = -gridSize;
                if (!gameStarted) gameStarted = true;
            }
            if (key === 'd' && !goingLeft) {
                dx = gridSize;
                dy = 0;
                if (!gameStarted) gameStarted = true;
            }
            if (key === 's' && !goingUp) {
                dx = 0;
                dy = gridSize;
                if (!gameStarted) gameStarted = true;
            }
        }

        initGame();

        // We leave the sessionStorage automatic redirect logic in place, but our timer will handle this
        (() => {
            sessionStorage.setItem('waitPage2StartTime', startTime);
        })();
    </script>
    <br>
    <br>
    <body>
        <h2 class="center-text">Still waiting for players to join...</h2>
    </body>
{% endblock %}